use std::str::FromStr;

use crate::syntax::{Op,Const,Expr,getvar,newvar,genvar,Var,Fundef,genname};

grammar;

Tier<Ops,NextTier>: Box<Expr> = {
    <e1:Tier<Ops,NextTier>> <op:Ops> <e2:NextTier> => Box::new(Expr::EOp(op, vec![e1,e2])),
    NextTier
};

pub Expr = Expr4;
//// Semicolon  とりあえず;が来たら切るようにする.
// "let f = 1;2 in f"とかはうまく動かないようにする.
// こっちのほうが健全では？？
Expr5: Box<Expr> = {
    <e1:Expr4> ";" <e2:Expr> =>  Box::new(Expr::ELet((genname(),genvar()),e1,e2)),
    <e1:Expr4> ";" => e1,
    Expr4,
};

//// 結合順序怪しいなあ
//Expr7:Box<Expr> = {
//    <e1:Expr6> <op:CondOp> <e2:Expr7> => Box::new(Expr::EOp(op, vec![e1,e2])),
//    Expr6
//};
//Expr6:Box<Expr> = {
//    <e1:Expr5> <op:TermOp> <e2:Expr6> => Box::new(Expr::EOp(op, vec![e1,e2])),
//    Expr5
//};
//Expr5:Box<Expr> = {
//    <e1:Expr4> <op:FactorOp> <e2:Expr5> => Box::new(Expr::EOp(op, vec![e1,e2])),
//    Expr4
//};
Expr4 : Box<Expr> = {
    "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr> => 
    Box::new(Expr::EIf(e1,e2,e3)),
    "let" <e1:Id> "=" <e2:Expr> "in" <e3:Expr4> => Box::new(Expr::ELet((e1,genvar()),e2,e3)),
    "let" "(" <e1:Pat> ")" "=" <e2:Expr> "in" <e3:Expr4> => Box::new(Expr::ELetTuple(e1,e2,e3)),
    "let" "rec" <f:Fun> "in" <cont:Expr4> => Box::new(Expr::ELetRec(f,cont)),
    //<e1:Expr4> ";" <e2:Expr31> =>  Box::new(Expr::ELet((genname(),genvar()),e1,e2)),
    //<e1:Expr31> ";" => e1,
    <e1:SimpleExpr> "." "(" <e2:Expr> ")" "<-" <e3:Expr4> => Box::new(Expr::EOp(Op::Store, vec![e1,e2,e3])),
    Expr31,
}; 

Expr31:Box<Expr> = {
    Expr3,
};


Elems: Vec<Box<Expr>> = {
    <e1:Elems> "," <e2:Expr> => {
        let mut v_ = e1;
        v_.push(e2);
        v_ 
    },
    <e1:Expr> "," <e2:Expr> => vec![e1,e2],
};
Pat: Vec<(Var,usize)> = {
    <e1:Pat> "," <e2:Id> => {
        let mut v_ = e1;
        v_.push((e2,genvar()));
        v_ 
    },
    <e1:Id> "," <e2:Id> => vec![(e1,genvar()),(e2,genvar())],
};

Fun : Fundef = {
    <n:Id> <args:Formal_Args> "=" <body:Expr> => 
        Fundef {
            name: (n,genvar()),
            args: args,
            body: body,
        },
};
Actual_Args: Vec<Box<Expr>> = {
    <a:Actual_Args> <e:SimpleExpr> => {
        let mut v_ = a;
        v_.push(e);
        v_
    },
    SimpleExpr => vec![<>],
};
Formal_Args : Vec<(Var,usize)> = {
    <a:Id_args> <v:Formal_Args> => 
    {
        let mut v_ = v;
        v_.insert(0,(a,genvar()));
        v_
    },
    <a:Id_args>  => vec![(a,genvar())],
};

ArrayCreate: () = {
    "Array.make" => (),
    "create_array" => (),
};
CondOp : Op = {
    "<=" => Op::LE,
    "<" => Op::LT,
    ">=" => Op::GE,
    ">" => Op::GT,
    "=" => Op::EQ,
    "<>" => Op::NE,
};

TermOp : Op = {
    "+." => Op::FAdd,
    "-." => Op::FSub,
    "+" => Op::Add,
    "-" => Op::Sub,
};
FactorOp : Op = {
    "*." => Op::FMul,
    "/." => Op::FDiv,
    "*" => Op::Mul,
    "/" => Op::Div,
};

Expr3 = Tier<CondOp, Expr2>; 
Expr2 = Tier<TermOp, Expr1>; 
Expr1 = Tier<FactorOp, Expr11>;
// App 
Expr11: Box<Expr> = {
    ArrayCreate <args:Actual_Args> => Box::new(Expr::EOp(Op::Array,args)),
    <e:SimpleExpr> <args:Actual_Args> => Box::new(Expr::EApp(e,args)),
    Expr0,
};
Expr0 = SimpleExpr;

pub SimpleExpr: Box<Expr> = {
    "(" <e:Expr> ")" => e,
    "()" => Box::new(Expr::EConst(Const::CUnit)),
    Int => Box::new(Expr::EConst(Const::CInt(<>))),
    Float => Box::new(Expr::EConst(Const::CFloat(<>))),
    Bool => Box::new(Expr::EConst(Const::CBool(<>))),
    Id => Box::new(Expr::EVar(<>)),
    "(" <e1:Elems> ")" => Box::new(Expr::ETuple(e1)),
   <e1:SimpleExpr> "." "(" <e2:Expr> ")" => Box::new(Expr::EOp(Op::Load, vec![e1,e2])),
};


pub Int: i32 = r"-?[0-9]+" => i32::from_str(<>).unwrap();
pub Float: f32 = {
    r"-?[0-9]+(\.[0-9]*)((e|E)(\+|-)?[0-9]+)?" => f32::from_str(<>).unwrap(),
};

pub Id_args: Var = {
    r"[a-z]([0-9]|[a-z]|[A-Z]|_)*" =>{
        getvar(String::from(<>))
    },
    "()" => genname(),
    "_" => genname(),

};
pub Id: Var = {
    r"[a-z]([0-9]|[a-z]|[A-Z]|_)*" => {
        println!("{}",<>);
        getvar(String::from(<>))
    },
    "_" => genname(),

};
pub Bool:bool = {
    "true" => true,
    "false" => false,
};

