use std::str::FromStr;

use crate::syntax::{Op,Const,Expr,getvar,newvar,genvar,Var,Fundef};

grammar;

Tier<Ops,NextTier>: Box<Expr> = {
    <e1:Tier<Ops,NextTier>> <op:Ops> <e2:NextTier> => Box::new(Expr::EOp(op, vec![e1,e2])),
    NextTier
};

pub Expr = Expr8;
//// Semicolon  とりあえず;が来たら切るようにする.
// "let f = 1;2 in f"とかはうまく動かないようにする.
// こっちのほうが健全では？？
Expr8: Box<Expr> = {
    <e1:Expr4> ";" <e2:Expr> =>  Box::new(Expr::ELet(newvar(),e1,e2)),
    <e1:Expr4> ";" => e1,
    Expr7,
};

// 結合順序怪しいなあ
Expr7:Box<Expr> = {
    <e1:Expr6> <op:CondOp> <e2:Expr7> => Box::new(Expr::EOp(op, vec![e1,e2])),
    Expr6
};
Expr6:Box<Expr> = {
    <e1:Expr5> <op:TermOp> <e2:Expr6> => Box::new(Expr::EOp(op, vec![e1,e2])),
    Expr5
};
Expr5:Box<Expr> = {
    <e1:Expr4> <op:FactorOp> <e2:Expr5> => Box::new(Expr::EOp(op, vec![e1,e2])),
    Expr4
};
Expr4 : Box<Expr> = {
    "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr4> => 
    Box::new(Expr::EIf(e1,e2,e3)),
    "let" <e1:Id> "=" <e2:Expr> "in" <e3:Expr4> => Box::new(Expr::ELet(e1,e2,e3)),
    "(" <e1:Elems> ")" => Box::new(Expr::ETuple(e1)),
    "let" "(" <e1:Pat> ")" "=" <e2:Expr> "in" <e3:Expr4> => Box::new(Expr::ELetTuple(e1,e2,e3)),
    "let" "rec" <f:Fun> "in" <cont:Expr4> => Box::new(Expr::ELetRec(f,cont)),
    <e1:SimpleExpr> "." "(" <e2:Expr> ")" "<-" <e3:Expr4> => Box::new(Expr::EOp(Op::Put(genvar()), vec![e1,e2,e3])),
    <e1:SimpleExpr> "." "(" <e2:Expr> ")" => Box::new(Expr::EOp(Op::Get(genvar()), vec![e1,e2])),
    Expr11,
}; 


Elems: Vec<Box<Expr>> = {
    <e1:Elems> "," <e2:Expr> => {
        let mut v_ = e1;
        v_.push(e2);
        v_ 
    },
    <e1:Expr> "," <e2:Expr> => vec![e1,e2],
};
Pat: Vec<Var> = {
    <e1:Pat> "," <e2:Id> => {
        let mut v_ = e1;
        v_.push(e2);
        v_ 
    },
    <e1:Id> "," <e2:Id> => vec![e1,e2],
};

Fun : Fundef = {
    <n:Id> <args:Formal_Args> "=" <body:Expr> => 
        Fundef {
            name: n,
            args: args,
            body: body,
        },
};
Actual_Args: Vec<Box<Expr>> = {
    <a:Actual_Args> <e:SimpleExpr> => {
        let mut v_ = a;
        v_.push(e);
        v_
    },
    SimpleExpr => vec![<>],
};
Formal_Args : Vec<Var> = {
    <a:Id> <v:Formal_Args> => 
    {
        let mut v_ = v;
        v_.insert(0,a);
        v_
    },
    <a:Id>  => vec![a],
};

ArrayCreate: () = {
    "Array.make" => (),
    "create_array" => (),
};
CondOp : Op = {
    "<=" => Op::LE,
    "<" => Op::LT,
    ">=" => Op::GE,
    ">" => Op::GT,
    "=" => Op::EQ,
    "<>" => Op::NE,
};

TermOp : Op = {
    "+." => Op::FAdd,
    "-." => Op::FSub,
    "+" => Op::Add,
    "-" => Op::Sub,
};
FactorOp : Op = {
    "*." => Op::FMul,
    "/." => Op::FDiv,
    "*" => Op::Mul,
    "/" => Op::Div,
};

//Expr3 = Tier<CondOp, Expr1>; 
//Expr2 = Tier<TermOp, Expr1>; 
//Expr1 = Tier<FactorOp, Expr11>;
// App 
Expr11: Box<Expr> = {
   <e:SimpleExpr> <args:Actual_Args> => Box::new(Expr::EApp(e,args)),
    Expr0,
};
Expr0 = SimpleExpr;

pub SimpleExpr: Box<Expr> = {
    "(" <e:Expr> ")" => e,
    "()" => Box::new(Expr::EConst(Const::CUnit)),
    Int => Box::new(Expr::EConst(Const::CInt(<>))),
    Float => Box::new(Expr::EConst(Const::CFloat(<>))),
    Bool => Box::new(Expr::EConst(Const::CBool(<>))),
    Id => Box::new(Expr::EVar(<>)),
};


pub Int: i32 = r"-?[0-9]+" => i32::from_str(<>).unwrap();
pub Float: f32 = r"-?[0-9]+\.[0-9]*" => f32::from_str(<>).unwrap();
pub Id: Var = r"[a-z]([0-9]|[a-z]|[A-Z]|_)*" => getvar(String::from(<>));
pub Bool:bool = {
    "true" => true,
    "false" => false,
};

